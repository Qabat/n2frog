function [omegaFROG, lenDelay, lenOmega, delDelay, delOmega, centOmega] = interpFROG(lambdaFROG)
    normalize = @(M) M/max(max(M));
    c = 299.792458; % speed of light in nm/fs    
    
    lenDelay = lambdaFROG(1);
    lenLambda = lambdaFROG(2);
    delDelay = lambdaFROG(3);
    delLambda = lambdaFROG(4);
    centLambda = lambdaFROG(5);
    
    lambdaFROG(1:5,:) = [];
    omegaFROG = lambdaFROG;
%     

    vectLambda = (centLambda-delLambda*lenLambda/2):delLambda:(centLambda+delLambda*(lenLambda/2-1)); % upewniæ siê tutaj czy srodek jest na 127 czy 128 pozycji
    delOmegaVector = 2*pi*c*delLambda./vectLambda(1:end-1).^2;

	iter = 1;
    vectOmega = 2*pi*c / vectLambda(1); % initialized with first value of omega
    for delOmega = delOmegaVector
        omega = vectOmega(iter) - delOmega;
        vectOmega = [vectOmega omega];
        iter = iter + 1;
    end

    iter = 1;
    for lambda = vectLambda
        omegaFROG(iter,:) = lambdaFROG(iter,:) * lambda^2 / (2*pi*c);
        iter = iter + 1;
    end
        
%     check if integrals in both domain are equal
%     A = sum(lambdaFROG(:,100).*vectLambda')
%     B = sum(omegaFROG(:,100).*vectOmega')
    
    newDeltaOmega = (vectOmega(end) - vectOmega(1)) / 255;
    omegaFROG = interp1(vectOmega, omegaFROG, vectOmega(1):newDeltaOmega:vectOmega(end),'spline');
    
    omegaFROG = normalize(omegaFROG);    
    lenOmega = length(vectOmega);
    delOmega = newDeltaOmega;
%     firstOmega = vectOmega(1);
    centOmega = 2*pi*c / centLambda; % centOmega has units of rad/fs

end

